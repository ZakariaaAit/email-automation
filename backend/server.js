const express = require('express');
const cors = require('cors');
const { randomUUID } = require('crypto');

const app = express();
app.use(cors());
app.use(express.json());

const PORT = 4000;

// Very simple AI agents (in a real app, map to OpenAI “agents” or models)
const aiAgents = [
  {
    id: 'agent_welcome',
    name: 'Welcome Agent',
    model: 'gpt-4.1-mini',
    systemPrompt: 'Writes warm welcome emails for new leads.'
  },
  {
    id: 'agent_sales',
    name: 'Sales Agent',
    model: 'gpt-4.1-mini',
    systemPrompt: 'Writes persuasive sales follow-up emails.'
  }
];

// Fake leads (normally this would be a separate feature)
const leads = [
  { id: 'lead_1', email: 'zack@example.com', firstName: 'Zakariaa' },
  { id: 'lead_2', email: 'abdel@example.com', firstName: 'abdellah' },
  { id: 'lead_3', email: 'ibtissam@example.com', firstName: 'Ibtissam' }
];

const campaigns = [];
const campaignEmails = []; // generated emails

const STATUS = {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  CANCELED: 'CANCELED',
  COMPLETED: 'COMPLETED'
};

const SCHEDULE_TYPE = {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY'
};

/**
 * Helpers
 */

function findCampaign(id) {
  return campaigns.find(c => c.id === id);
}

function validateCampaignPayload(body) {
  const errors = [];

  if (!body.name || typeof body.name !== 'string') {
    errors.push('name is required');
  }

  if (!body.scheduleType || !Object.values(SCHEDULE_TYPE).includes(body.scheduleType)) {
    errors.push('scheduleType must be DAILY or WEEKLY');
  }

  if (!body.durationDays || typeof body.durationDays !== 'number' || body.durationDays <= 0) {
    errors.push('durationDays must be a positive number');
  }

  if (!body.startDateUtc) {
    errors.push('startDateUtc is required');
  } else if (isNaN(Date.parse(body.startDateUtc))) {
    errors.push('startDateUtc must be a valid ISO date');
  }

  if (!body.timeZone || typeof body.timeZone !== 'string') {
    errors.push('timeZone is required');
  }

  if (!body.aiAgentId || !aiAgents.find(a => a.id === body.aiAgentId)) {
    errors.push('aiAgentId is invalid');
  }

  if (!Array.isArray(body.leadIds) || body.leadIds.length === 0) {
    errors.push('leadIds must be a non-empty array');
  } else {
    const invalid = body.leadIds.filter(
      id => !leads.find(l => l.id === id)
    );
    if (invalid.length) {
      errors.push('some leadIds do not exist: ' + invalid.join(', '));
    }
  }

  if (body.scheduleType === SCHEDULE_TYPE.DAILY) {
    if (
      typeof body.dailyEmailsPerDay !== 'number' ||
      body.dailyEmailsPerDay <= 0
    ) {
      errors.push('dailyEmailsPerDay must be a positive number');
    }
  }

  if (body.scheduleType === SCHEDULE_TYPE.WEEKLY) {
    if (!Array.isArray(body.weeklyDays) || body.weeklyDays.length === 0) {
      errors.push('weeklyDays must be a non-empty array of weekdays');
    }
    if (
      typeof body.weeklyEmailsPerDay !== 'number' ||
      body.weeklyEmailsPerDay <= 0
    ) {
      errors.push('weeklyEmailsPerDay must be a positive number');
    }
  }

  return errors;
}

function isCampaignActiveNow(campaign) {
  if (campaign.status !== STATUS.ACTIVE) return false;

  const now = new Date();
  const start = new Date(campaign.startDateUtc);
  const end = new Date(start.getTime() + campaign.durationDays * 24 * 60 * 60 * 1000);

  if (now < start || now > end) {
    return false;
  }

  // Simplified schedule logic – real app would use time zones & hours
  if (campaign.scheduleType === SCHEDULE_TYPE.DAILY) {
    return true; // any day in duration
  }

  if (campaign.scheduleType === SCHEDULE_TYPE.WEEKLY) {
    const weekdayIdx = now.getUTCDay(); // 0 = Sun
    const map = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
    const today = map[weekdayIdx];
    return campaign.weeklyDays.includes(today);
  }

  return false;
}

// Generate a deterministic slot key (date-only for simplicity)
function buildSlotKey(campaign) {
  const now = new Date();
  const day = now.toISOString().slice(0, 10); // YYYY-MM-DD
  return `${campaign.id}_${day}`;
}

function generateEmailContent(campaign, lead) {
  // Stub AI logic – here you’d call OpenAI
  const agent = aiAgents.find(a => a.id === campaign.aiAgentId);
  const subject = `[${campaign.name}] Hello ${lead.firstName || ''}`.trim();
  const bodyHtml = `
    <p>Hi ${lead.firstName || 'there'},</p>
    <p>This message is generated by agent <strong>${agent.name}</strong>.</p>
    <p>We are glad to have you in campaign <strong>${campaign.name}</strong>.</p>
    <p>Best regards,<br/>Your SaaS</p>
  `;
  return { subject, bodyHtml };
}

/**
 * Scheduler logic (can be run manually or via setInterval)
 */
function runSchedulerOnce() {
  console.log('Running scheduler at', new Date().toISOString());

  const now = new Date();

  campaigns.forEach(campaign => {
    if (!isCampaignActiveNow(campaign)) return;

    const slotKey = buildSlotKey(campaign);

    // Check how many emails we can send for this campaign now
    let quota = 0;
    if (campaign.scheduleType === SCHEDULE_TYPE.DAILY) {
      quota = campaign.dailyEmailsPerDay;
    } else if (campaign.scheduleType === SCHEDULE_TYPE.WEEKLY) {
      quota = campaign.weeklyEmailsPerDay;
    }

    if (quota <= 0) return;

    // For simplicity, pick the first leads that haven't received an email today
    const eligibleLeads = campaign.leadIds
      .map(id => leads.find(l => l.id === id))
      .filter(Boolean)
      .filter(lead => {
        // idempotency: if there is already an email for this campaign + lead + slotKey, skip
        return !campaignEmails.find(
          e =>
            e.campaignId === campaign.id &&
            e.leadId === lead.id &&
            e.scheduledSlotKey === slotKey
        );
      })
      .slice(0, quota);

    eligibleLeads.forEach(lead => {
      const { subject, bodyHtml } = generateEmailContent(campaign, lead);

      const emailRecord = {
        id: randomUUID(),
        campaignId: campaign.id,
        leadId: lead.id,
        scheduledSlotKey: slotKey,
        subject,
        bodyHtml,
        status: 'GENERATED', // in a real app we’d later send it
        createdAt: now.toISOString()
      };

      campaignEmails.push(emailRecord);

      console.log(
        `Generated email for campaign=${campaign.id} lead=${lead.email} slot=${slotKey}`
      );
    });
  });
}

/**
 * Optionally run scheduler every minute
 * (comment out if you prefer manual trigger only)
 */
// setInterval(runSchedulerOnce, 60 * 1000);

/**
 * Routes
 */

// List AI agents
app.get('/api/ai-agents', (req, res) => {
  res.json(aiAgents);
});

// Create campaign
app.post('/api/campaigns', (req, res) => {
  const errors = validateCampaignPayload(req.body);
  if (errors.length) {
    return res.status(400).json({ errors });
  }

  const id = randomUUID();
  const now = new Date().toISOString();

  const campaign = {
    id,
    name: req.body.name,
    scheduleType: req.body.scheduleType,
    dailyEmailsPerDay: req.body.scheduleType === SCHEDULE_TYPE.DAILY
      ? req.body.dailyEmailsPerDay
      : null,
    weeklyEmailsPerDay: req.body.scheduleType === SCHEDULE_TYPE.WEEKLY
      ? req.body.weeklyEmailsPerDay
      : null,
    weeklyDays: req.body.scheduleType === SCHEDULE_TYPE.WEEKLY
      ? req.body.weeklyDays
      : null,
    durationDays: req.body.durationDays,
    startDateUtc: req.body.startDateUtc,
    timeZone: req.body.timeZone,
    aiAgentId: req.body.aiAgentId,
    leadIds: req.body.leadIds,
    status: STATUS.ACTIVE,
    createdAt: now,
    updatedAt: now
  };

  campaigns.push(campaign);
  res.status(201).json(campaign);
});

// List campaigns with simple filters
app.get('/api/campaigns', (req, res) => {
  const { status } = req.query;
  let result = campaigns;

  if (status) {
    result = result.filter(c => c.status === status);
  }

  res.json(result);
});

// Get campaign details
app.get('/api/campaigns/:id', (req, res) => {
  const campaign = findCampaign(req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Not found' });

  const emails = campaignEmails.filter(e => e.campaignId === campaign.id);
  res.json({ ...campaign, emailsCount: emails.length });
});

// Change campaign status: pause/resume/cancel
app.patch('/api/campaigns/:id/status', (req, res) => {
  const campaign = findCampaign(req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Not found' });

  const { action } = req.body;
  if (!['pause', 'resume', 'cancel'].includes(action)) {
    return res.status(400).json({ error: 'Invalid action' });
  }

  if (action === 'pause') {
    campaign.status = STATUS.PAUSED;
  } else if (action === 'resume') {
    campaign.status = STATUS.ACTIVE;
  } else if (action === 'cancel') {
    campaign.status = STATUS.CANCELED;
  }

  campaign.updatedAt = new Date().toISOString();
  res.json(campaign);
});

// Manual trigger: run scheduler only for this campaign (simplified)
app.post('/api/campaigns/:id/run', (req, res) => {
  const campaign = findCampaign(req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Not found' });

  if (!isCampaignActiveNow(campaign)) {
    return res.status(400).json({ error: 'Campaign is not active right now' });
  }

  const beforeCount = campaignEmails.length;
  runSchedulerOnce();
  const afterCount = campaignEmails.length;

  res.json({
    message: 'Scheduler executed',
    newEmailsGenerated: afterCount - beforeCount
  });
});

// List generated emails for a campaign
app.get('/api/campaigns/:id/emails', (req, res) => {
  const campaign = findCampaign(req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Not found' });

  const emails = campaignEmails.filter(e => e.campaignId === campaign.id);
  res.json(emails);
});

// Manual trigger for whole system
app.post('/api/scheduler/run', (req, res) => {
  const before = campaignEmails.length;
  runSchedulerOnce();
  const after = campaignEmails.length;
  res.json({ message: 'Scheduler executed', newEmailsGenerated: after - before });
});

app.listen(PORT, () => {
  console.log(`Backend listening on http://localhost:${PORT}`);
});
